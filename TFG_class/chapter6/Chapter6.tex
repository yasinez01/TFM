\chapter[Funcionamiento interno]{Funcionamiento interno}
\label{Chap6}

En el capítulo \ref{Chap5} se ha descrito el funcionamiento del Ecosistema de Aprendizaje desde el punto de vista del usuario, detallando las pantallas, los flujos y las interacciones. En esta sección se aborda el sistema desde la perspectiva del desarrollador, explicando la arquitectura interna, los patrones aplicados, el funcionamiento del backend y diversos fragmentos de código relevantes para comprender cómo se ha construido la solución.

El objetivo de esta sección es aportar una visión técnica del proyecto, profundizando en la estructura del código, la implementación de la lógica de negocio, la comunicación entre las capas y las decisiones técnicas que han guiado el desarrollo.

\section{Arquitectura técnica y organización del proyecto}

El sistema se ha implementado siguiendo una arquitectura por capas combinada con el 
patrón \textit{Command Query Responsibility Segregation} (CQRS). Esta combinación proporciona una estructura clara, mantenible y fácilmente escalable. La separación entre comandos y consultas permite dividir de forma explícita las operaciones que modifican estado de aquellas que únicamente lo leen.

La estructura general del proyecto puede verse en el siguiente esquema: \\
\begin{forest}
	pic dir tree,
	where level=0{} {
		directory,
	},
		[Proyecto
	[WebUI
	[Controllers]
	[Views]
	[Scripts]
	[ViewModels]
	]
	[Application
	[Commands]
	[Queries]
	[DTOs]
	[Interfaces]
	]
	[Infrastructure
	[Servicios]
	[Migrations]
	]
	[Domain
	[Entities]
	]
	]
\end{forest}
\\Cada una de estas áreas cumple un rol específico:
\begin{description}
	\item[WebUI:] interacción con el usuario, controladores, vistas y modelos de presentación.
	\item[Application:] lógica de negocio, implementación de CQRS, validaciones y DTOs.
	\item[Infrastructure:] acceso a datos, repositorios, migraciones y servicios externos.
	\item[Domain:] entidades principales y reglas del dominio de negocio.
\end{description}

\section{Implementación de consultas (Query Handlers)}

El controlador mostrado en el capítulo \ref{Chap4} de formaciones llama internamente a consultas modeladas como \textit{Handlers}. Estas consultas se encuentran en la capa \textit{Application} y permiten recuperar datos de manera estructurada.

A continuación se muestra un ejemplo simplificado del \textit{Handler} correspondiente a la obtención del listado de formaciones:
\begin{lstlisting}[style=csharp, caption={Clase Handler que realiza una consulta para obtener formaciones.},label=code:ej3]
public class GetAllFormacionesQueryHandler : 
IRequestHandler<GetAllFormacionesQuery, ApiRespuesta<List<FormacionListDTO>>>
{
	private readonly IFormacionesDataService _formacionesDataService;
	
	public GetAllFormacionesQueryHandler(IFormacionesDataService formacionesDataService)
	{
		_formacionesDataService = formacionesDataService;
	}
	
	public async Task<ApiRespuesta<List<FormacionListDTO>>> Handle(GetAllFormacionesQuery request,
	CancellationToken cancellationToken)
	{
		var apiRespuesta = new ApiRespuesta<List<FormacionListDTO>> { 
		Data = new List<FormacionListDTO>(), Tipo = TipoRespuesta.Error };
		
		List<FormacionListDTO> formaciones = await Task.Run(() => _formacionesDataService
		.SelectAll(request.Filtros, cancellationToken));
		if (formaciones != null)
		{			
			apiRespuesta.Tipo = TipoRespuesta.Success;
			apiRespuesta.Data = formaciones;
		}
		
		return apiRespuesta;
	}
}
\end{lstlisting}

Este fragmento de código define una clase llamada \textit{GetAllFormacionesQueryHandler}. Esta clase se encarga de manejar una solicitud para obtener todas las formaciones en el sistema, basándose en los filtros proporcionados en la consulta. En el constructor, se inyecta una dependencia del servicio \textit{IFormacionesDataService}, que se utiliza para acceder a los datos relacionados con las formaciones. El método \textit{Handle} es el encargado de ejecutar la consulta. Recibe como parámetros el objeto \textit{request}, que contiene los filtros para la consulta, y un \textit{cancellationToken} para permitir la cancelación de la operación si es necesario. Dentro del método, se inicializa una \textit{apiRespuesta} con un estado de error. Luego, se ejecuta de forma asíncrona el método \textit{SelectAll} del servicio \textit{formacionesDataService}, que realiza la consulta a la base de datos utilizando los filtros y el token de cancelación. Si la consulta devuelve una lista de formaciones, el tipo de respuesta se actualiza a \textit{Success}, y la lista obtenida se asigna al campo \textit{Data} de la respuesta. Finalmente, el método retorna la respuesta que puede contener tanto los datos de las formaciones como un posible error si no se encuentran datos o si ocurre alguna otra falla.
La clase \textit{FormacionListDTO} que en este caso representa una formación contiene:

\begin{lstlisting}[style=csharp, caption={Clase DTO para filtrar las formaciones.},label=code:ej4]
public class FormacionFiltrosDTO
{	
	public string FiltroTexto { get; set; }
	public string FiltroArea { get; set; }
	public string FiltroTipo { get; set; }
	public string FiltroModalidad { get; set; }
	public string FiltroTipoConocimiento { get; set; }
	public string FiltroAsistente { get; set; }
	public int? FiltroFormacionEstado { get; set; }
	public int? FiltroPedido { get; set; }
	public DateTime? FiltroFechaInicioDesde { get; set; }
	public DateTime? FiltroFechaInicioHasta { get; set; }
	public bool? FiltroBonificable { get; set; }
	public bool? FiltroAccionCorrectiva { get; set; }
	public bool? FiltroPendienteFactura { get; set; }
}
\end{lstlisting}
En cada \textit{Query} tenemos un parámetro de filtrado. 

\section{Implementación de comandos (Command Handlers)}

Las operaciones que modifican el estado de la aplicación, como crear o actualizar una
formación, se implementan mediante \textit{Command Handlers}. Su diseño es similar al de 
las consultas, pero incluye validaciones y lógica de negocio adicional.
\begin{lstlisting}[style=csharp, caption={Clase Handler para crear una formación.},label=code:ej5]
public class CreateFormacionCommandHandler :
IRequestHandler<CreateFormacionCommand, ApiRespuesta<FormacionDTO>>
{
	private readonly IFormacionesDataService _formacionesDataService;
	public CreateFormacionCommandHandler(IFormacionesDataService formacionesDataService)
	{            
		_formacionesDataService = formacionesDataService;
	}
	
	public async Task<ApiRespuesta<FormacionDTO>> Handle(CreateFormacionCommand request,
	CancellationToken cancellationToken)
	{            
		var formacionDTO = request.FormacionDTO;
		var apiRespuesta = new ApiRespuesta<FormacionDTO>() { Tipo = TipoRespuesta.Error
		, Data = formacionDTO };
		
		if (formacionDTO.ListaErrores.Count == 0) {
			
			InicializarCampos(formacionDTO);
			
			formacionDTO = await Task.Run(() => _formacionesDataService
			.Insert(formacionDTO, cancellationToken));
			
			if (formacionDTO != null)
			{
				apiRespuesta.Tipo = TipoRespuesta.Success;
				apiRespuesta.Data = formacionDTO;
			}
		}
		
		return apiRespuesta;
	}
	
	private void InicializarCampos(FormacionDTO formacionDTO)
	{
		formacionDTO.FormacionID = 0;
		formacionDTO.FormacionEstadoID = (int)EFormacionEstados.PendienteAprobacion;
		formacionDTO.CreadoPor = Utility.UsuarioActual.NombreSinDominio;
		formacionDTO.CreadoEn = DateTime.Now;
		formacionDTO.ModificadoPor = formacionDTO.CreadoPor;
		formacionDTO.ModificadoEn = formacionDTO.CreadoEn;
		
		formacionDTO.CuestionarioDTO.CuestionarioInicialID = 0;
		formacionDTO.CuestionarioDTO.CreadoPor = formacionDTO.CreadoPor;
		formacionDTO.CuestionarioDTO.CreadoEn = formacionDTO.CreadoEn;
		formacionDTO.CuestionarioDTO.ModificadoPor = formacionDTO.CreadoPor;
		formacionDTO.CuestionarioDTO.ModificadoEn = formacionDTO.CreadoEn;
		
		if (formacionDTO.AdjuntoFormFile != null
		&& formacionDTO.AdjuntoFormFile.Length > 0)
		{
			using (var memoryStream = new MemoryStream())
			{
				formacionDTO.AdjuntoFormFile
				.CopyTo(memoryStream);
				byte[] archivoBytes = memoryStream.ToArray();
				
				formacionDTO.Adjunto = archivoBytes;
				formacionDTO.AdjuntoNombre = formacionDTO.AdjuntoFormFile.FileName;
			}
		}
	}
	
}
\end{lstlisting}

Este fragmento de código define una clase llamada \textit{CreateFormacionCommandHandler}. Su propósito es manejar la creación de una nueva formación. En el constructor, se inyecta el servicio \textit{IFormacionesDataService}, utilizado para insertar la nueva formación en la base de datos.

El método \textit{Handle} recibe como parámetros el objeto \textit{request}, que contiene los datos de la formación a crear, y un \textit{cancellationToken}. Inicialmente, se crea una respuesta \textit{apiRespuesta} con un estado de error y los datos de la formación. Si la lista de errores de la formación está vacía, se procede a inicializar varios campos del objeto \textit{formacionDTO} mediante el método \textit{InicializarCampos}, que establece valores predeterminados como el estado de la formación y los datos de creación. Luego, se ejecuta la inserción de la formación de manera asíncrona utilizando el método \textit{Insert} del servicio \textit{formacionesDataService}. Si la inserción es exitosa, se actualiza la respuesta a \textit{Success} y se asignan los datos de la formación insertada.
Finalmente, el método \textit{Handle} retorna una respuesta que puede contener la formación recién creada o un error si ocurre algún problema en el proceso.

Este tipo de comandos garantiza que todas las modificaciones sigan las reglas de dominio
establecidas en la capa \textit{Domain}. Además, para los comandos, tenemos clases validator por cada comando donde validamos los parámetros de los comandos. Es decir, validar que no sean nulos cuando son parámetros obligatorios, validar longitud de cadenas si tienen un máximo para guardar en base de datos....
\begin{lstlisting}[style=csharp, caption={Clase Validator para crear una formación.},label=code:ej6]
	public class CreateFormacionCommandValidator : AbstractValidator<CreateFormacionCommand>
	{
		public CreateFormacionCommandValidator()
		{
			
			RuleFor(v => v.FormacionDTO.Nombre)
			.NotEmpty()
			.NotNull()
			.MaximumLength(256);
			
			RuleFor(v => v.FormacionDTO.Lugar)
			.NotEmpty()
			.NotNull()
			.MaximumLength(256);
			
			RuleFor(v => v.FormacionDTO.FechaInicio)
			.LessThanOrEqualTo(l => l.FormacionDTO.FechaFin);
		}
	}
\end{lstlisting}
En este caso, validamos que:
\begin{itemize}
	\item El valor de \textit{Nombre} de la formación no sea nulo y que no tenga más de 256 caracteres.
	\item El valor de \textit{Lugar} de la formación no sea nulo y que no tenga más de 256 caracteres.
	\item El valor de \textit{FechaInicio} de la formación no sea posterior al valor de \textit{FechaFin} de la formación.
\end{itemize}

Si alguna regla no se cumple se guarda el error y se le muestra al usuario para que rellene el formulario correctamente antes de poder crear la formación.
\section{Acceso a datos e infraestructura}

La capa \textit{Infrastructure} implementa las interfaces definidas en \textit{Application} mediante Entity Framework. Las entidades del dominio se mapean a tablas mediante Fluent API:

\begin{lstlisting}[style=csharp, caption={Mapeo de tablas mediante Fluent API.},label=code:ej7]
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
	modelBuilder.Entity<Formacion>(entity =>
	{
		entity.ToTable("Formaciones");
		entity.Property(f => f.Nombre)
		.HasMaxLength(200)
		.IsRequired();
	});
}
\end{lstlisting}
Este fragmento de código define una sobrecarga del método \textit{OnModelCreating} en una clase que hereda de \textit{DbContext}. En este método, se configura el modelo de la entidad \textit{Formacion} utilizando el objeto \textit{modelBuilder}. La entidad \textit{Formacion} se mapea a la tabla \textit{Formaciones} en la base de datos mediante \textit{entity.ToTable\{ "Formaciones" \}}. Luego, se configura la propiedad \textit{Nombre} de la entidad para que sea obligatoria (\textit{IsRequired()}) y tenga una longitud máxima de 200 caracteres (\textit{HasMaxLength(200)}). Esta configuración garantiza que la propiedad \textit{Nombre} sea requerida y tenga un límite de caracteres en la base de datos.

Asimismo, cada cambio en el modelo genera una migración que se aplica sobre SQL Server, manteniendo sincronizada la estructura de la base de datos con el código fuente. Los métodos que implementan las interfaces tienen de lógica solamente el mapeo y la interacción con las tablas de base de datos. 
\begin{lstlisting}[style=csharp, caption={Mapeo de tablas mediante Fluent API.},label=code:ej8]
public async Task<FormacionDTO> Insert(FormacionDTO formacionDTO, 
CancellationToken cancellationToken)
{
	using (var transaction = _context.Database.BeginTransaction())
	{
		try
		{
			CuestionarioInicial cuestionario = _mapper.Map<CuestionarioInicial>
			(formacionDTO.CuestionarioDTO);
			
			_context.CuestionarioInicial.Add(cuestionario);
			await _context.SaveChangesAsync(cancellationToken);
			
			formacionDTO.CuestionarioInicialID = cuestionario.CuestionarioInicialID;
			Formacion formacion = _mapper.Map<Formacion>(formacionDTO);
			
			_context.Formacion.Add(formacion);
			await _context.SaveChangesAsync(cancellationToken);
			
			formacionDTO.FormacionID = formacion.FormacionID;
			formacionDTO.ValoracionUsuario.ForEach(valorador =>
			{
				Valoracion valoracionEntity = new Valoracion
				{
					FormacionID = formacion.FormacionID,
					ValoracionUsuario = valorador
				};
				_context.Valoracion.Add(valoracionEntity);
			});
			await _context.SaveChangesAsync(cancellationToken);
			transaction.Commit();
			_logger.LogInformation("Exito al crear la formación");
			
		}
		catch (Exception ex)
		{
			transaction.Dispose();
			_logger.LogError(ex, "Error al crear la formación");
			formacionDTO = null;
		}
	}
	
	return formacionDTO;
}
\end{lstlisting}

Este fragmento de código define un método asíncrono \textit{Insert} que inserta una nueva formación en la base de datos. Primero, se inicia una transacción de base de datos. Luego, se mapea el objeto \textit{formacionDTO.CuestionarioDTO} a una entidad \textit{CuestionarioInicial} y se guarda en la base de datos. Después, se mapea \textit{formacionDTO} a una entidad \textit{Formacion} y se agrega a la base de datos. A continuación, se insertan las valoraciones de los usuarios asociadas a la formación. Si todas las operaciones son exitosas, se confirma la transacción. En caso de error, se captura la excepción, se deshace la transacción y se registra el error. Finalmente, el método retorna el objeto \textit{formacionDTO}.


\section{Sistema de permisos y filtros de autorización}

El control de acceso a los distintos métodos del controlador se realiza mediante un filtro personalizado que valida los roles del usuario autenticado. Esto permite proteger acciones como ver detalles de una formación o tramitar solicitudes.

\begin{lstlisting}[style=csharp, caption={Clase que valida el permiso del usuario para poder consultar vistas o realizar acciones.},label=code:ej9]
public class TienePermisosFilterAttribute : AuthorizeAttribute, IAuthorizationFilter
{
	
	private EAutorizacionPermisos AutorizacionPermisos { get; set; }
	public TienePermisosFilterAttribute(EAutorizacionPermisos autorizacionPermisos)
	{
		AutorizacionPermisos = autorizacionPermisos;
	}
	
	public void OnAuthorization(AuthorizationFilterContext context)
	{
		
		var usuario = Utility.UsuarioActual;
		
		if (context.HttpContext.User
		.HasClaim("NotAuthorized", "NotAuthorized") 
		|| usuario == null)
		{
			context.Result = new RedirectToActionResult(
			"HttpStatusCodeHandler",
			"Error", 
			new { statusCode = 403 });
		}
		else 
		{
			switch (AutorizacionPermisos) {
				case EAutorizacionPermisos.NINGUNO:
				if ((usuario.AutorizacionPermisos & EAutorizacionPermisos.NINGUNO) 
				!= EAutorizacionPermisos.NINGUNO)           
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error", 
				 new { statusCode = 403 });                        
				break;
				
				case EAutorizacionPermisos.SOLICITANTE:
				if ((usuario.AutorizacionPermisos & EAutorizacionPermisos.SOLICITANTE) 
				!= EAutorizacionPermisos.SOLICITANTE)
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error", 
				 new { statusCode = 403 });
				break;
				
				case EAutorizacionPermisos.PYV:
				if ((usuario.AutorizacionPermisos & EAutorizacionPermisos.PYV) 
				!= EAutorizacionPermisos.PYV)
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error", 
				 new { statusCode = 403 });
				break;
				
				case EAutorizacionPermisos.ADMINISTRADOR:
				if (((usuario.AutorizacionPermisos & EAutorizacionPermisos.ADMINISTRADOR) 
				!= EAutorizacionPermisos.ADMINISTRADOR) && !usuario.EsUsuarioSuplantado)
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error",
				  new { statusCode = 403 });
				break;
				
				case EAutorizacionPermisos.RESPONSABLENEGOCIO:
				if (((usuario.AutorizacionPermisos & EAutorizacionPermisos.RESPONSABLENEGOCIO) 
				!= EAutorizacionPermisos.RESPONSABLENEGOCIO) && !usuario.EsUsuarioSuplantado)
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error", 
				 new { statusCode = 403 });
				break;
				
				default:
				context.Result = new RedirectToActionResult(
				"HttpStatusCodeHandler",
				 "Error",
				  new { statusCode = 403 });
				break;
			}
		}
		
	}
}
\end{lstlisting}
Este fragmento de código define una clase \textit{TienePermisosFilterAttribute} que hereda de \textit{AuthorizeAttribute} e implementa la interfaz \textit{IAuthorizationFilter}. Su función es verificar si el usuario tiene los permisos necesarios para acceder a un recurso. En el constructor, se recibe un parámetro \textit{AutorizacionPermisos}, que indica el nivel de permiso requerido. El método \textit{OnAuthorization} comprueba si el usuario está autorizado para realizar la acción solicitada, evaluando su rol mediante un \textit{switch} según el tipo de permiso. Si el usuario no tiene el permiso adecuado o está marcado como \textit{NotAuthorized}, se redirige a una página de error con el código de estado 403.

El uso de este filtro en los controladores permite centralizar la gestión de permisos y 
evitar duplicación de lógica.

\section{Sistema de notificaciones y enlaces únicos}

El envío automático de correos electrónicos es una de las piezas clave del flujo interno. Tenemos un comando encargado de envío de correos después de que se aplique algún tramite, como por ejemplo al agregar un asistente a una formación le llega un correo para poder aceptar o rechazar la convocatoria. También tenemos otro controlador que es un recordatorio que envía diferentes correos según las fechas. Por ejemplo, cuando un asistente es agregado a una formación y queda una semana para que la formación comience, si ese asistente aún no ha aceptado ni rechazado la convocatoria automáticamente le llega un correo de recordatorio ya que cuando quede un solo día para que comience la formación, si no confirmó entonces se rechaza automáticamente.

\section{Procesamiento de encuestas y valoraciones}

Al finalizar una acción formativa, el sistema envía automáticamente una encuesta de 
eficacia. Cada respuesta queda asociada a un asistente y a una formación, y el promedio 
se calcula dinámicamente. Este proceso se refleja posteriormente en la pestaña \textit{Valoraciones}, visible para los roles autorizados.

\section{Conclusión técnica}

El diseño interno del Ecosistema de Aprendizaje combina una arquitectura moderna con 
patrones avanzados y una estricta separación por capas. Esto ha permitido 
desarrollar un sistema robusto, mantenible y fácilmente ampliable. La modularidad del 
código y el uso de Entity Framework, servicios desacoplados y filtros de permisos garantizan que la aplicación pueda evolucionar en el futuro incorporando nuevas funcionalidades sin comprometer su estabilidad.
