\chapter[Estructura del proyecto]{Estructura del proyecto}
\label{Chap3}

\section{Presentación}
La capa de presentación constituye el nivel superior de la arquitectura y se encarga de gestionar la interacción directa con el usuario. En esta capa se encuentra el proyecto Interfaz de Usuario Web (WebUI), que corresponde a la aplicación web visible para los usuarios finales. Dentro de WebUI se definen las vistas, es decir, los elementos visuales que conforman la interfaz, junto con los estilos CSS que determinan su apariencia.

Asimismo, en esta capa se desarrollan las clases TypeScript, responsables de manejar los distintos eventos del usuario y de definir las acciones que se ejecutan como respuesta a dichos eventos. Los controladores también forman parte de esta capa y su función principal es invocar a las clases de niveles inferiores para realizar operaciones sobre la base de datos. Estas clases, situadas en capas más profundas, se explicarán más adelante. Se incluyen también los ViewModels, que son modelos diseñados específicamente para las vistas. Estos modelos facilitan la organización y presentación de los datos de forma estructurada y coherente, permitiendo que la información se muestre correctamente en la interfaz web. En esencia, actúan como una plantilla que define tanto la apariencia como el comportamiento de los datos dentro de la interfaz de usuario.

Un ejemplo ilustrativo puede observarse en el Listado \ref{code:ej1}, donde se presentan varios métodos pertenecientes al controlador de la clase Formación. El primer método, que se invoca mediante una petición POST, devuelve un conjunto de formaciones almacenadas en la base de datos, permitiendo además aplicar filtros de búsqueda a través de la variable filtros que se construye a partir de los parámetros (filtroTexto, filtroArea, filtroTipo, etc), en caso de que ocurra algún error y no se devuelven las formaciones se muestra un mensaje al usuario en pantalla. En cambio, el segundo método se ejecuta mediante una petición GET, que solicita un recurso específico del servidor y recupera una formación concreta identificada por su ID pasado como parámetro en la línea 38 (FormacionID), aquí también se hace una validación para comprobar el tipo de respuesta ya sea un error para informar al usuario, un aviso de que esa persona no está autorizada a ver los detalles de esa formación ó hay éxito que en ese caso se genera el ViewModel correspondiente y se le pasa los datos de la formación para poder mostrarlos por pantalla al usuario. 

Además de los métodos de consulta, el controlador incluye también operaciones para crear, modificar y eliminar registros de formaciones. Otra nota importante aquí es cuando ponemos a los métodos [TienePermisosFilter(EAutorizacionPermisos.SOLICITANTE)], esto nos valida el rol del usuario el cual llama al método. En este caso definimos que solamente aquellos que mínimo el rol de Solicitante podrán acceder a esté método, aunque más tarde explicaremos con más detalle el tema de los roles y como funciona la validación de permisos.
\begin{lstlisting}[style=R, caption=Controlador del proyecto WebUI con métodos de selección de formaciones almacenados en base de datos,label=code:ej1]
[HttpPost("[action]")]
[TienePermisosFilter(EAutorizacionPermisos.SOLICITANTE)]
public async Task<IActionResult> GetListadoFormaciones([DataSourceRequest] DataSourceRequest request, string filtroTexto, string filtroArea, string filtroTipo, string filtroModalidad, string filtroAsistente, int? filtroFormacionEstado, DateTime? filtroFechaInicioDesde, DateTime? filtroFechaInicioHasta, bool? filtroBonificable, bool? filtroAccionCorrectiva, int? filtroPedido, bool? filtroPendienteFactura)
{
	logger.LogInformation("Obtener el listado de formaciones filtrado");
	
	var filtros = new FormacionFiltrosDTO
	{
		FiltroTexto = filtroTexto,
		FiltroArea = filtroArea,
		FiltroTipo = filtroTipo,
		FiltroModalidad = filtroModalidad,
		FiltroAsistente = filtroAsistente,
		FiltroFormacionEstado = filtroFormacionEstado,
		FiltroFechaInicioDesde = filtroFechaInicioDesde,
		FiltroFechaInicioHasta = filtroFechaInicioHasta,
		FiltroBonificable = filtroBonificable,
		FiltroAccionCorrectiva = filtroAccionCorrectiva,
		FiltroPedido = filtroPedido,
		FiltroPendienteFactura = filtroPendienteFactura
	};
	
	var formacionesRespuesta = await Mediator.Send(new GetAllFormacionesQuery(filtros));
	
	if (formacionesRespuesta.Tipo == TipoRespuesta.Error)
	{
		ModelState.AddModelError("ListadoGridError", "Ha ocurrido un error al obtener el listado de formaciones.");
	}
	
	return Json(formacionesRespuesta.Data.ToDataSourceResult(request, ModelState));
}	
	
	
[HttpGet("[action]/{FormacionID}")]
[TienePermisosFilter(EAutorizacionPermisos.SOLICITANTE)]
public async Task<IActionResult> Detalle(int formacionID)
{
	logger.LogInformation($"Pantalla de detalle de la formacion: {formacionID}");
	
	var formacion = await Mediator.Send(new GetSingleFormacionQuery(formacionID));
	
	if (formacion.Tipo == TipoRespuesta.Error)
	{
		TempData["NotificacionMensaje"] = NotificacionMensaje.FormacionObtenerError.ToString();
		return RedirectToAction("Index");
	}
	else if (formacion.Tipo == TipoRespuesta.NoAutorizado)
	{
		return RedirectToAction("HttpStatusCodeHandler", "Error", new { statusCode = 403 });
	}
	
	var viewModel = new FormacionViewModel();
	viewModel.FormacionGeneral = viewModel.FormacionGeneral.GetViewModel(formacion.Data);
	
	return View(viewModel);
}
\end{lstlisting}


\section{Aplicación}
La capa de aplicación representa el nivel en el que se concentra la lógica de negocio del sistema. En este nivel se implementa el principio de Command Query Responsibility Segregation (CQRS), mediante el cual cada proceso o acción empresarial se modela como un comando o una consulta independiente. Este patrón arquitectónico permite diferenciar las operaciones que modifican el estado del sistema (comandos) de aquellas que únicamente recuperan información (consultas), promoviendo así una estructura más ordenada, clara y escalable.

Dentro de esta capa también se definen las clases conocidas como Data Transfer Objects (DTO). Estas entidades sirven como vehículos de intercambio de información entre las diferentes capas, evitando que los modelos internos se expongan directamente. Su propósito es agrupar y transportar los datos necesarios para ejecutar una acción concreta, garantizando una comunicación sencilla, coherente y desacoplada entre componentes de la aplicación.

Finalmente, las operaciones relacionadas con los comandos y las consultas —como se muestra en el Listado \ref{code:ej2}— se declaran mediante interfaces localizadas en esta misma capa, mientras que su implementación específica se desarrolla en la capa inferior.

\begin{lstlisting}[style=R, caption=Interfaz de formaciones con métodos para llevar a cabo las operaciones sobre la base de datos,label=code:ej2]
	public interface IFormacionesDataService
	{
		Task<List<FormacionListDTO>> SelectAll(FormacionFiltrosDTO filtros, CancellationToken cancellationToken);
		Task<List<FormacionListDTO>> SelectAllConHorario(CancellationToken cancellationToken);
		Task<List<ActualizarAreasFormacionesDTO>> SelectAllActualizarAreasFormaciones(DateTime filtroFecha, CancellationToken cancellationToken);
		Task<List<FormacionModificacionHistoricoDTO>> SelectAllFormacionModificacionHistoricoToday(CancellationToken cancellationToken); 
		Task<List<FormacionModificacionHistoricoDTO>> SelectAllFormacionModificacionBonificablesHistoricoToday(List<FormacionModificacionHistoricoDTO> formacionesModificacionHistoricoDTO, CancellationToken cancellationToken); 
		Task<List<PedidoDTO>> SelectAllPedidos(PedidoFiltrosDTO filtros, List<EmpresaExterna>? empresasExternas ,CancellationToken cancellationToken);
		Task<List<FacturaPedidoDTO>> SelectAllFacturasPedido(int pedidoID, List<EmpresaExterna>? empresasExternas, CancellationToken cancellationToken);
		Task<List<int>> SelectAllTramitadas(CancellationToken cancellationToken);
		Task<List<PedidosDrop>> SelectAllAreasPedidos(CancellationToken cancellationToken);
		Task<List<FormacionListDTO>> SelectFormacionesArea(FormacionFiltrosDTO filtros, List<string> areas, CancellationToken cancellationToken);
		Task<List<string>> SelectAreasFormacion(int formacionId, CancellationToken cancellationToken);
		Task<bool> PerteneceFormacionArea(int formacionId, List<string> areas, CancellationToken cancellationToken);
		Task<List<FormacionListDTO>> SelectAllOtraEmpresa(FormacionFiltrosDTO filtros, CancellationToken cancellationToken);
		Task<List<FormacionEstadoHistoricoDTO>> SelectHistoricoEstadoFormacion(int formacionID, CancellationToken cancellationToken);
		Task<List<FormacionModificacionHistoricoDTO>> SelectHistoricoCambiosFormacion(int formacionID, CancellationToken cancellationToken);
		Task<List<FormacionCompleteDTO>> SelectAllComplete(FormacionFiltrosDTO? filtros, CancellationToken cancellationToken);
		Task<List<int>> SelectAreas(List<string> areas, CancellationToken cancellationToken);
		Task<FormacionDTO> SelectSingle(int formacionID, CancellationToken cancellationToken);
		Task<FormacionDTO> SelectValoradoresPendientes(FormacionDTO formacion, CancellationToken cancellationToken);
		Task<bool> EstaEnAsistentes(int formacionID, string user, CancellationToken cancellationToken);
		Task<List<FormacionListDTO>> DropFormacionesValidadas(List<FormacionListDTO> formaciones, CancellationToken cancellationToken);
		Task<List<FormacionCompleteDTO>> DropFormacionesValidadas(List<FormacionCompleteDTO> formaciones, CancellationToken cancellationToken);
		Task<int?> SelectPosicionNuevoCodigo(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<int?> SelectPosicionNuevoCodigoOtraEmpresa(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<bool> ExisteCodigo(string codigo, CancellationToken cancellationToken);
		Task<bool> ExisteCodigoOtraEmpresa(string codigo, CancellationToken cancellationToken);
		Task<FormacionDTO> SelectSingleOtraEmpresa(int formacionID, CancellationToken cancellationToken);
		Task<bool> ComprobarValoracionCompletada(int formacionID);
		Task<FormacionDTO> Insert(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<FormacionDTO> InsertOtraEmpresa(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<PedidoDTO> AsignarPedidoFormacion(int formacionID, int pedidoID, CancellationToken cancellationToken);
		Task<FormacionDTO> Update(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<FormacionDTO> UpdateSharePoint(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<FormacionDTO> UpdateConCuestionario(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<FormacionDTO> UpdateConValoracion(FormacionDTO formacionDTO, CancellationToken cancellationToken);
		Task<ActualizarAreasFormacionesDTO> UpdateAreasFormaciones(ActualizarAreasFormacionesDTO formacionDTO, CancellationToken cancellationToken);
		Task<bool?> DesvincularPedido(int pedidoID, CancellationToken cancellationToken);
		Task<List<FormacionHorarioDTO>> SelectAllHorarios(int formacionID, string compañia, CancellationToken cancellationToken);
		Task<bool> Delete(int formacionID, CancellationToken cancellationToken);
	}
\end{lstlisting}
\section{Infraestructura}
La capa de infraestructura constituye el nivel responsable de la interacción con los recursos externos y de proporcionar los servicios necesarios para que las demás capas puedan operar correctamente. En esta capa se ubican las clases encargadas de acceder a sistemas externos, tales como bases de datos, sistemas de archivos, servicios web o cualquier otro recurso externo que el sistema requiera.

Las clases que pertenecen a este nivel implementan las interfaces definidas en la capa de aplicación, cumpliendo así el principio de inversión de dependencias y garantizando una arquitectura más modular y desacoplada. Gracias a este enfoque, el resto del sistema no necesita conocer los detalles técnicos de cómo se realizan las operaciones externas, sino únicamente la interfaz que las define, lo que facilita la sustitución o actualización de componentes sin afectar al funcionamiento general.

Otro elemento importante presente en esta capa son los procesos de migración, que hacen referencia al conjunto de procedimientos destinados a trasladar o actualizar la estructura y los datos de una base de datos. Las migraciones permiten mantener la coherencia entre el modelo de datos y el código fuente del proyecto, especialmente durante las fases de desarrollo o actualización del sistema. Mediante estas operaciones se pueden aplicar cambios de esquema, incorporar nuevas tablas o modificar relaciones existentes, asegurando la integridad de la información y la compatibilidad entre versiones.
\section{Dominio}
La capa de dominio constituye el núcleo esencial del sistema, ya que en ella se define la lógica de negocio que modela los procesos y reglas fundamentales de la aplicación. En este nivel se ubican las entidades, que representan los elementos principales del modelo de negocio y encapsulan tanto sus atributos como el comportamiento asociado.

El propósito de esta capa es reflejar con fidelidad la realidad del problema que la aplicación pretende resolver, garantizando la coherencia interna y la integridad de los datos mediante las operaciones que se realizan sobre dichas entidades.

Una característica clave del dominio es su independencia respecto a la infraestructura y a los elementos externos, como bases de datos o servicios. Esta separación asegura que las reglas de negocio permanezcan estables y no se vean afectadas por los cambios tecnológicos, facilitando así la evolución y el mantenimiento del sistema a largo plazo.